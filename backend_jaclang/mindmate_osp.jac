# MindMate Harmony Space - Advanced OSP Multi-Agent System
# Implements: Multi-Agent Design, OSP Graph, byLLM Integration

glob datetime = __import__('datetime');
glob iso_timestamp = __import__('datetime').datetime.now().isoformat();

# ============================================================================
# OSP GRAPH - NAMED NODE TYPES (Requirement 2)
# ============================================================================

node UserProfile {
    has user_id: str;
    has name: str;
    has created_at: str;
    has age: int = 25;
    has mood_count: int = 0;
    has total_intensity: float = 0.0;
    has avg_intensity: float = 0.0;
    has preferences: dict = {};
}

node MoodEntry {
    has entry_id: str;
    has emotion_name: str;
    has intensity: float;
    has user_input: str;
    has timestamp: str;
    has triggers: list = [];
    has activities: list = [];
    has sentiment_score: float = 0.5;
    has context_tags: list = [];
    has analyzed: bool = False;
}

node RecommendationNode {
    has rec_id: str;
    has title: str;
    has content: str;
    has rec_type: str;
    has generated_at: str;
    has priority: int = 3;
    has relevance_score: float = 0.0;
    has status: str = "pending";
    has personalization_factors: list = [];
    has validated: bool = False;
}

node InsightNode {
    has insight_id: str;
    has insight_type: str;
    has title: str;
    has description: str;
    has generated_at: str;
    has confidence_score: float = 0.0;
    has data_points: int = 0;
    has actionable: bool = True;
}

node TriggerPattern {
    has pattern_id: str;
    has trigger_name: str;
    has occurrence_count: int = 0;
    has avg_intensity: float = 0.0;
    has impact_score: float = 0.0;
}

node AnalysisReport {
    has report_id: str;
    has generated_at: str;
    has agents_involved: list = [];
    has summary: dict = {};
}

# ============================================================================
# OSP GRAPH - NAMED EDGE TYPES (Requirement 2)
# ============================================================================

edge LOGS_MOOD {
    has logged_at: str;
    has device: str = "web";
}

edge GENERATES_REC {
    has generated_by: str;
    has generated_at: str;
    has confidence: float = 0.0;
    has reasoning: str = "";
}

edge HAS_INSIGHT {
    has discovered_at: str;
    has relevance: float = 0.0;
    has priority: int = 1;
}

edge RELATED_TO {
    has relation_type: str;
    has strength: float = 0.0;
    has correlation_score: float = 0.0;
}

edge VALIDATES {
    has validator_agent: str;
    has validated_at: str;
    has validation_score: float = 0.0;
    has passed: bool = True;
}

edge TRIGGERS_MOOD {
    has impact_level: float = 0.0;
    has frequency: int = 1;
}

edge SPAWNED_BY {
    has parent_agent: str;
    has spawn_reason: str;
    has spawn_time: str;
}

# ============================================================================
# AGENT 1: MoodAnalyzerAgent (Requirement 1 - Multi-Agent)
# Responsibilities: Pattern analysis, trend detection, graph traversal
# ============================================================================

walker MoodAnalyzerAgent {
    has user_id: str;
    has analysis_depth: int = 30;
    has mood_entries: list = [];
    has patterns: dict = {};
    has trigger_analysis: dict = {};
    has completed: bool = False;
    
    can analyze with entry {
        root [0];
        visit [-->];
    }
    
    can process_user with UserProfile entry {
        if here.user_id == self.user_id {
            print(f"[MoodAnalyzerAgent] Analyzing user: {here.user_id}");
            print(f"[MoodAnalyzerAgent] Total moods logged: {here.mood_count}");
            
            # Graph traversal - find all mood entries
            mood_nodes = [-->];
            
            for mood_node in mood_nodes {
                entry_data = {
                    "emotion": mood_node.emotion_name,
                    "intensity": mood_node.intensity,
                    "triggers": mood_node.triggers,
                    "timestamp": mood_node.timestamp,
                    "user_input": mood_node.user_input
                };
                self.mood_entries.append(entry_data);
            }
            
            # Analyze emotion patterns inline
            emotion_counts = {};
            intensity_sum = 0.0;
            
            for entry in self.mood_entries {
                emotion = entry["emotion"] if "emotion" in entry else "neutral";
                intensity = entry["intensity"] if "intensity" in entry else 0.5;
                
                if emotion not in emotion_counts {
                    emotion_counts[emotion] = {"count": 0, "total_intensity": 0.0};
                }
                
                emotion_counts[emotion]["count"] += 1;
                emotion_counts[emotion]["total_intensity"] += intensity;
                intensity_sum += intensity;
            }
            
            num_entries = len(self.mood_entries);
            avg_intensity = intensity_sum / num_entries if num_entries > 0 else 0.0;
            
            # Find dominant emotion
            dominant_emotion = "neutral";
            max_count = 0;
            for emotion in emotion_counts {
                if emotion_counts[emotion]["count"] > max_count {
                    max_count = emotion_counts[emotion]["count"];
                    dominant_emotion = emotion;
                }
            }
            
            # Analyze trigger correlations inline
            trigger_impact = {};
            for entry in self.mood_entries {
                triggers = entry["triggers"] if "triggers" in entry else [];
                for trigger in triggers {
                    if trigger not in trigger_impact {
                        trigger_impact[trigger] = {"count": 0, "total_intensity": 0.0, "avg_intensity": 0.0};
                    }
                    trigger_impact[trigger]["count"] += 1;
                    entry_intensity = entry["intensity"] if "intensity" in entry else 0.5;
                    trigger_impact[trigger]["total_intensity"] += entry_intensity;
                }
            }
            
            for trigger in trigger_impact {
                if trigger_impact[trigger]["count"] > 0 {
                    trigger_impact[trigger]["avg_intensity"] = trigger_impact[trigger]["total_intensity"] / trigger_impact[trigger]["count"];
                }
            }
            
            self.patterns = {
                "emotion_distribution": emotion_counts,
                "avg_intensity": avg_intensity,
                "total_entries": num_entries,
                "dominant_emotion": dominant_emotion,
                "emotional_diversity": len(emotion_counts)
            };
            self.trigger_analysis = trigger_impact;
            
            print(f"[MoodAnalyzerAgent] Analysis complete - {len(self.mood_entries)} entries processed");
            
            # Spawn next agent in pipeline
            spawn here ++> RecommendationAgent(
                user_id=self.user_id,
                analysis_data=self.patterns,
                trigger_data=self.trigger_analysis
            );
        }
    }
}

# ============================================================================
# AGENT 2: RecommendationAgent (Requirement 1 & 3 - Multi-Agent + byLLM)
# Responsibilities: Generate personalized recommendations, content creation
# Uses byLLM for GENERATIVE tasks (Requirement 3.1)
# ============================================================================

walker RecommendationAgent {
    has user_id: str;
    has analysis_data: dict;
    has trigger_data: dict;
    has recommendations: list = [];
    
    can generate with entry {
        print(f"[RecommendationAgent] Generating personalized recommendations");
        dominant_em = self.analysis_data["dominant_emotion"] if "dominant_emotion" in self.analysis_data else "unknown";
        print(f"[RecommendationAgent] Based on: {dominant_em} emotion");
        
        # ==== INLINE: Breathing recommendation ====
        dominant_emotion = self.analysis_data["dominant_emotion"] if "dominant_emotion" in self.analysis_data else "neutral";
        avg_intensity = self.analysis_data["avg_intensity"] if "avg_intensity" in self.analysis_data else 0.5;
        
        technique_name = "Mindful Breathing";
        instructions = "Breathe naturally. Count each breath. When mind wanders, gently return to counting.";
        duration = "5 minutes";
        priority_level = 3;
        
        if dominant_emotion == "anxious" {
            technique_name = "4-7-8 Breathing";
            instructions = "Breathe in for 4 counts, hold for 7, exhale for 8. This activates your parasympathetic nervous system.";
            duration = "5 minutes";
            priority_level = 5;
        } elif dominant_emotion == "angry" {
            technique_name = "Box Breathing";
            instructions = "Inhale 4, hold 4, exhale 4, hold 4. Used by Navy SEALs for stress management.";
            duration = "3 minutes";
            priority_level = 5;
        } elif dominant_emotion == "sad" {
            technique_name = "Gentle Belly Breathing";
            instructions = "Place hand on belly. Breathe deeply, feeling your belly rise and fall. Focus on warmth and comfort.";
            duration = "7 minutes";
            priority_level = 4;
        }
        
        rec_id = f"breath_{self.user_id}_{len(self.recommendations)}";
        title = f"{technique_name} Exercise";
        content = f"{instructions}\n\nRecommended duration: {duration}\n\nPersonalized for {dominant_emotion} emotions at intensity {avg_intensity:.1f}";
        
        rec = {
            "rec_id": rec_id,
            "title": title,
            "content": content,
            "rec_type": "breathing",
            "priority": priority_level,
            "personalization_factors": [dominant_emotion, f"intensity_{avg_intensity:.1f}"]
        };
        
        self.recommendations.append(rec);
        
        # ==== INLINE: Activity recommendation ====
        primary_trigger = "general";
        max_impact = 0.0;
        trigger_data_local = self.trigger_data if self.trigger_data else {};
        for trigger in trigger_data_local {
            impact_score = trigger_data_local[trigger]["impact_score"] if "impact_score" in trigger_data_local[trigger] else 0.0;
            if impact_score > max_impact {
                max_impact = impact_score;
                primary_trigger = trigger;
            }
        }
        
        activity_name = "Nature Connection";
        description = "Spend 15 minutes in nature or near a window. Natural light and greenery boost serotonin.";
        category = "wellbeing";
        
        if primary_trigger == "work" {
            activity_name = "Pomodoro Break";
            description = "Take a 5-minute walk or stretch every 25 minutes. Studies show this improves focus and mood.";
            category = "productivity";
        } elif primary_trigger == "stress" {
            activity_name = "Progressive Muscle Relaxation";
            description = "Tense and release each muscle group from toes to head. Reduces cortisol levels.";
            category = "relaxation";
        } elif primary_trigger == "social" {
            activity_name = "Mindful Journaling";
            description = "Write for 10 minutes about your feelings without judgment. Process social interactions safely.";
            category = "reflection";
        } elif primary_trigger == "sleep" {
            activity_name = "Wind-Down Routine";
            description = "No screens 1 hour before bed. Try reading, gentle stretching, or herbal tea.";
            category = "sleep_hygiene";
        }
        
        rec = {
            "rec_id": f"activity_{self.user_id}_{len(self.recommendations)}",
            "title": activity_name,
            "content": f"{description}\n\nRecommended because you've been experiencing {primary_trigger}-related emotions frequently.",
            "rec_type": "activity",
            "priority": 4,
            "personalization_factors": [primary_trigger, category]
        };
        
        self.recommendations.append(rec);
        
        # ==== INLINE: Affirmation recommendation ====
        trend = self.analysis_data["trend"] if "trend" in self.analysis_data else "stable";
        
        affirmation = "I am present and open to this moment. I accept myself as I am.";
        
        if dominant_emotion == "happy" {
            affirmation = "I embrace this joy and let it flow through me. Happiness is my natural state.";
        } elif dominant_emotion == "sad" {
            affirmation = "I honor my sadness and trust that it will pass. I am resilient and worthy of comfort.";
        } elif dominant_emotion == "anxious" {
            affirmation = "I am safe in this moment. I release what I cannot control and focus on what I can.";
        } elif dominant_emotion == "angry" {
            affirmation = "I acknowledge my anger without judgment. I choose how to express it constructively.";
        } elif dominant_emotion == "calm" {
            affirmation = "I am at peace. I trust the process of life and my ability to navigate it.";
        } elif dominant_emotion == "energetic" {
            affirmation = "I channel my energy into meaningful actions. I am capable and motivated.";
        }
        
        if trend == "improving" {
            affirmation += "\n\nYour emotional wellbeing is trending positively. Keep nurturing yourself!";
        } elif trend == "declining" {
            affirmation += "\n\nYou're going through a challenging time. Remember, this is temporary and you're not alone.";
        }
        
        rec = {
            "rec_id": f"affirm_{self.user_id}_{len(self.recommendations)}",
            "title": "Personal Affirmation",
            "content": affirmation,
            "rec_type": "affirmation",
            "priority": 3,
            "personalization_factors": [dominant_emotion, trend]
        };
        
        self.recommendations.append(rec);
        
        # ==== INLINE: Professional recommendation ====
        total_entries = self.analysis_data["total_entries"] if "total_entries" in self.analysis_data else 0;
        
        recommend_professional = False;
        urgency = "low";
        
        if avg_intensity > 0.75 and total_entries >= 5 {
            recommend_professional = True;
            urgency = "medium";
        }
        
        if dominant_emotion in ["sad", "anxious", "hopeless"] and avg_intensity > 0.7 {
            recommend_professional = True;
            urgency = "high";
        }
        
        if recommend_professional {
            priority = 5 if urgency == "high" else 4;
            
            rec = {
                "rec_id": f"professional_{self.user_id}_{len(self.recommendations)}",
                "title": "Consider Professional Support",
                "content": f"Based on your recent emotional patterns, speaking with a mental health professional could be beneficial.\n\n" +
                          "Remember: Seeking help is a sign of strength, not weakness. Many people benefit from therapy, especially during challenging times.\n\n" +
                          "Resources:\n- Psychology Today therapist finder\n- BetterHelp or Talkspace for online therapy\n- Crisis Text Line: Text HOME to 741741 (24/7)",
                "rec_type": "professional",
                "priority": priority,
                "personalization_factors": [dominant_emotion, f"urgency_{urgency}", "professional_support"]
            };
            
            self.recommendations.append(rec);
        }
        
        print(f"[RecommendationAgent] Generated {len(self.recommendations)} recommendations");
        
        # Spawn validation agent
        spawn here ++> ValidationAgent(
            user_id=self.user_id,
            recommendations=self.recommendations,
            context=self.analysis_data
        );
    }
}

# ============================================================================
# AGENT 3: ValidationAgent (Requirement 1 & 3 - Multi-Agent + byLLM)
# Responsibilities: Score recommendations, quality control
# Uses byLLM for ANALYTICAL tasks (Requirement 3.2)
# ============================================================================

walker ValidationAgent {
    has user_id: str;
    has recommendations: list;
    has context: dict;
    has validation_results: list = [];
    
    can validate with entry {
        print(f"[ValidationAgent] Validating {len(self.recommendations)} recommendations");
        
        for rec in self.recommendations {
            # ==== INLINE: calculate_relevance_score ====
            score = 0.0;
            
            # Factor 1: Priority alignment (0-0.25)
            priority_score = rec["priority"] / 5.0 * 0.25;
            score += priority_score;
            
            # Factor 2: Personalization depth (0-0.25)
            personalization_count = len(rec["personalization_factors"]);
            personalization_score_val = personalization_count / 4.0;
            if personalization_score_val > 1.0 {
                personalization_score_val = 1.0;
            }
            score += personalization_score_val * 0.25;
            
            # Factor 3: Context relevance (0-0.30)
            dominant_emotion = self.context["dominant_emotion"] if "dominant_emotion" in self.context else "";
            if dominant_emotion in str(rec["personalization_factors"]) {
                score += 0.30;
            } else {
                score += 0.10;
            }
            
            # Factor 4: Intensity appropriateness (0-0.20)
            avg_intensity = self.context["avg_intensity"] if "avg_intensity" in self.context else 0.5;
            if rec["priority"] >= 4 and avg_intensity > 0.7 {
                score += 0.20;
            } elif rec["priority"] <= 3 and avg_intensity < 0.5 {
                score += 0.15;
            } else {
                score += 0.05;
            }
            
            if score > 1.0 {
                score = 1.0;
            }
            
            # ==== INLINE: assess_quality ====
            quality = 0.5;
            
            # Check content length
            content_length = len(rec["content"]);
            if content_length >= 50 and content_length <= 500 {
                quality += 0.20;
            }
            
            # Check for actionable content
            content_lower = rec["content"].lower();
            has_action = False;
            if "breathe" in content_lower or "try" in content_lower or "practice" in content_lower or "consider" in content_lower or "take" in content_lower or "spend" in content_lower or "write" in content_lower {
                has_action = True;
            }
            if has_action {
                quality += 0.15;
            }
            
            # Check for specificity
            if rec["rec_type"] in ["breathing", "activity", "professional"] {
                quality += 0.15;
            }
            
            if quality > 1.0 {
                quality = 1.0;
            }
            
            # ==== Store validation results ====
            validation = {
                "rec_id": rec["rec_id"],
                "relevance_score": score,
                "quality_score": quality,
                "validated": score >= 0.5 and quality >= 0.6,
                "validator": "ValidationAgent"
            };
            
            self.validation_results.append(validation);
            
            # Update recommendation with validation
            rec["relevance_score"] = score;
            rec["validated"] = validation["validated"];
            
            status = "âœ“" if validation["validated"] else "âœ—";
            print(f"[ValidationAgent] {status} {rec['title']}: relevance={score:.2f}, quality={quality:.2f}");
        }
        
        # Spawn insight generator
        spawn here ++> InsightGeneratorAgent(
            user_id=self.user_id,
            context=self.context,
            recommendations=self.recommendations,
            validation_results=self.validation_results
        );
    }
}

# ============================================================================
# AGENT 4: InsightGeneratorAgent (Requirement 1 - Multi-Agent)
# Responsibilities: Create actionable insights, identify patterns
# ============================================================================

walker InsightGeneratorAgent {
    has user_id: str;
    has context: dict;
    has recommendations: list;
    has validation_results: list;
    has insights: list = [];
    
    can generate with entry {
        print(f"[InsightGeneratorAgent] Generating insights from analysis");
        
        # ==== INLINE: generate_trend_insight ====
        avg_intensity = self.context["avg_intensity"] if "avg_intensity" in self.context else 0.5;
        total_entries = self.context["total_entries"] if "total_entries" in self.context else 0;
        trend = self.context["trend"] if "trend" in self.context else "stable";
        
        recent_avg = self.context["recent_avg"] if "recent_avg" in self.context else 0.5;
        older_avg = self.context["older_avg"] if "older_avg" in self.context else 0.5;
        
        description = f"Your emotional state has been relatively stable with an average intensity of {avg_intensity:.2f}. Consistency is valuable for understanding your patterns.";
        
        if trend == "improving" {
            description = f"Your emotional wellbeing is on an upward trend! Recent mood intensity ({recent_avg:.2f}) is higher than your earlier baseline ({older_avg:.2f}).";
        } elif trend == "declining" {
            description = f"You're experiencing a downward trend in mood. Recent intensity ({recent_avg:.2f}) is lower than your previous baseline. This is a good time to engage in self-care.";
        }
        
        insight = {
            "insight_id": f"trend_{self.user_id}",
            "insight_type": "trend",
            "title": f"Emotional Trend: {trend.title()}",
            "description": description,
            "confidence_score": 0.85 if total_entries >= 7 else 0.65,
            "data_points": total_entries,
            "actionable": trend == "declining"
        };
        
        self.insights.append(insight);
        
        # ==== INLINE: generate_pattern_insight ====
        emotion_dist = self.context["emotion_distribution"] if "emotion_distribution" in self.context else {};
        dominant = self.context["dominant_emotion"] if "dominant_emotion" in self.context else "neutral";
        diversity = self.context["emotional_diversity"] if "emotional_diversity" in self.context else 0;
        
        if emotion_dist {
            total_count = 0;
            for key in emotion_dist {
                total_count += emotion_dist[key]["count"];
            }
            dominant_percentage = (emotion_dist[dominant]["count"] / total_count * 100) if total_count > 0 else 0;
            
            description2 = f"Your dominant emotion is '{dominant}' ({dominant_percentage:.0f}% of entries). ";
            
            if diversity >= 5 {
                description2 += "You're experiencing a healthy range of emotions, which indicates emotional flexibility.";
            } elif diversity <= 2 {
                description2 += "You're experiencing a limited emotional range. This could indicate emotional suppression or a specific life situation.";
            } else {
                description2 += f"You're experiencing {diversity} different emotional states, showing moderate emotional awareness.";
            }
            
            insight2 = {
                "insight_id": f"pattern_{self.user_id}",
                "insight_type": "pattern",
                "title": f"Emotional Pattern: {dominant.title()} Dominance",
                "description": description2,
                "confidence_score": 0.90,
                "data_points": total_count,
                "actionable": diversity <= 2 or dominant_percentage > 70
            };
            
            self.insights.append(insight2);
        }
        
        # ==== INLINE: generate_recommendation_insight ====
        validated_count = 0;
        for v in self.validation_results {
            if v["validated"] {
                validated_count += 1;
            }
        }
        total_recs = len(self.recommendations);
        
        high_priority_count = 0;
        for r in self.recommendations {
            if r["priority"] >= 4 {
                high_priority_count += 1;
            }
        }
        
        if high_priority_count > 0 {
            description3 = f"You have {high_priority_count} high-priority recommendations that deserve immediate attention. ";
            description3 += "These are personalized based on your recent emotional patterns and could provide significant benefit.";
            
            insight3 = {
                "insight_id": f"rec_{self.user_id}",
                "insight_type": "recommendation",
                "title": "Priority Recommendations Available",
                "description": description3,
                "confidence_score": 0.95,
                "data_points": total_recs,
                "actionable": True
            };
            
            self.insights.append(insight3);
        }
        
        # ==== INLINE: generate_milestone_insight ====
        milestone_found = False;
        
        if total_entries >= 30 and not milestone_found {
            insight4 = {
                "insight_id": f"milestone_30_{self.user_id}",
                "insight_type": "milestone",
                "title": "Month of Mindfulness",
                "description": f"A full month of emotional tracking - you're building lasting habits! Tracking {total_entries} moods shows commitment to your wellbeing. Consistency builds emotional intelligence.",
                "confidence_score": 1.0,
                "data_points": total_entries,
                "actionable": False
            };
            self.insights.append(insight4);
            milestone_found = True;
        }
        
        if total_entries >= 14 and not milestone_found {
            insight4 = {
                "insight_id": f"milestone_14_{self.user_id}",
                "insight_type": "milestone",
                "title": "Two-Week Milestone",
                "description": f"Two weeks of self-awareness - patterns are emerging! Tracking {total_entries} moods shows commitment to your wellbeing. Consistency builds emotional intelligence.",
                "confidence_score": 1.0,
                "data_points": total_entries,
                "actionable": False
            };
            self.insights.append(insight4);
            milestone_found = True;
        }
        
        if total_entries >= 7 and not milestone_found {
            insight4 = {
                "insight_id": f"milestone_7_{self.user_id}",
                "insight_type": "milestone",
                "title": "Week of Consistency",
                "description": f"You've completed a full week of mood tracking! Tracking {total_entries} moods shows commitment to your wellbeing. Consistency builds emotional intelligence.",
                "confidence_score": 1.0,
                "data_points": total_entries,
                "actionable": False
            };
            self.insights.append(insight4);
        }
        
        print(f"[InsightGeneratorAgent] Generated {len(self.insights)} actionable insights");
        
        # Create final report
        total_relevance = 0.0;
        for v in self.validation_results {
            total_relevance += v["relevance_score"];
        }
        avg_relevance = total_relevance / len(self.validation_results) if len(self.validation_results) > 0 else 0.0;
        
        report_data = {
            "user_id": self.user_id,
            "analysis_summary": self.context,
            "recommendations": self.recommendations,
            "insights": self.insights,
            "validation_summary": {
                "total_recommendations": len(self.recommendations),
                "validated_count": validated_count,
                "avg_relevance": avg_relevance
            },
            "agents_involved": ["MoodAnalyzerAgent", "RecommendationAgent", "ValidationAgent", "InsightGeneratorAgent"],
            "generated_at": iso_timestamp
        };
        
        report report_data;
    }
}

# ============================================================================
# COORDINATOR WALKER - Entry Point for Multi-Agent System
# ============================================================================

walker SystemCoordinator {
    has user_id: str;
    has operation: str = "full_analysis";
    
    can coordinate with entry {
        print("=" * 70);
        print("ðŸŒ¸ MindMate Harmony Space - Multi-Agent Analysis System");
        print("=" * 70);
        print(f"User ID: {self.user_id}");
        print(f"Operation: {self.operation}");
        print(f"Agents: MoodAnalyzerAgent â†’ RecommendationAgent â†’ ValidationAgent â†’ InsightGeneratorAgent");
        print("=" * 70);
        print("");
        
        # Spawn the multi-agent pipeline
        spawn here ++> MoodAnalyzerAgent(user_id=self.user_id);
    }
}

# ============================================================================
# GRAPH BUILDER - Initialize OSP Graph with Sample Data
# ============================================================================

walker GraphBuilder {
    has user_id: str = "user_demo_001";
    has user_name: str = "Demo User";
    
    can build with entry {
        print("ðŸ—ï¸  Building OSP Graph Structure");
        print("=" * 70);
        
        # Create UserProfile node
        user_node = here ++> UserProfile(
            user_id=self.user_id,
            name=self.user_name,
            age=28,
            preferences={"theme": "calm", "notifications": True},
            created_at=iso_timestamp
        );
        
        print(f"âœ“ Created UserProfile node: {self.user_id}");
        
        # Create diverse mood entries with named edges
        mood_data = [
            {
                "emotion": "happy",
                "intensity": 0.75,
                "input": "Had a great workout and felt accomplished!",
                "triggers": ["exercise", "achievement"],
                "activities": ["gym", "running"]
            },
            {
                "emotion": "anxious",
                "intensity": 0.65,
                "input": "Project deadline approaching, feeling overwhelmed",
                "triggers": ["work", "deadline", "stress"],
                "activities": ["work", "planning"]
            },
            {
                "emotion": "calm",
                "intensity": 0.45,
                "input": "Morning meditation session was peaceful",
                "triggers": ["meditation", "morning_routine"],
                "activities": ["meditation", "breathing"]
            },
            {
                "emotion": "sad",
                "intensity": 0.55,
                "input": "Missing family and friends today",
                "triggers": ["social", "isolation", "loneliness"],
                "activities": ["reflection", "journaling"]
            },
            {
                "emotion": "energetic",
                "intensity": 0.82,
                "input": "Coffee kicked in! Ready to tackle the day",
                "triggers": ["caffeine", "morning", "motivation"],
                "activities": ["work", "socializing"]
            },
            {
                "emotion": "frustrated",
                "intensity": 0.68,
                "input": "Technical issues blocking my progress",
                "triggers": ["work", "technology", "obstacles"],
                "activities": ["problem_solving", "break"]
            },
            {
                "emotion": "grateful",
                "intensity": 0.70,
                "input": "Received unexpected support from a colleague",
                "triggers": ["social", "support", "kindness"],
                "activities": ["work", "socializing"]
            },
            {
                "emotion": "anxious",
                "intensity": 0.72,
                "input": "Presentation tomorrow, need to prepare more",
                "triggers": ["work", "public_speaking", "performance"],
                "activities": ["preparation", "rehearsal"]
            }
        ];
        
        # Create mood nodes with LOGS_MOOD edges
        idx = 0;
        for mood in mood_data {
            mood_node = MoodEntry(
                entry_id=f"{self.user_id}_mood_{idx}",
                emotion_name=mood["emotion"],
                intensity=mood["intensity"],
                user_input=mood["input"],
                triggers=mood["triggers"],
                activities=mood["activities"],
                timestamp=iso_timestamp,
                sentiment_score=mood["intensity"]
            );
            
            user_node ++> mood_node;
            
            user_node.mood_count += 1;
            user_node.total_intensity += mood["intensity"];
            idx += 1;
        }
        
        user_node.avg_intensity = user_node.total_intensity / user_node.mood_count if user_node.mood_count > 0 else 0.0;
        
        print(f"âœ“ Created {len(mood_data)} MoodEntry nodes with LOGS_MOOD edges");
        print(f"âœ“ User avg intensity: {user_node.avg_intensity:.2f}");
        print("=" * 70);
        print("");
        
        report {
            "status": "graph_built",
            "user_id": self.user_id,
            "mood_entries_created": len(mood_data),
            "avg_intensity": user_node.avg_intensity,
            "graph_structure": "OSP compliant with named nodes and edges"
        };
    }
}
